// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package services

import (
	"time"

	"github.com/Petryanin/love-bot/internal/config"
	mock "github.com/stretchr/testify/mock"
)

// NewMockPlanner creates a new instance of MockPlanner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPlanner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPlanner {
	mock := &MockPlanner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPlanner is an autogenerated mock type for the Planner type
type MockPlanner struct {
	mock.Mock
}

type MockPlanner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPlanner) EXPECT() *MockPlanner_Expecter {
	return &MockPlanner_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type MockPlanner
func (_mock *MockPlanner) Add(p *Plan) error {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*Plan) error); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlanner_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockPlanner_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - p
func (_e *MockPlanner_Expecter) Add(p interface{}) *MockPlanner_Add_Call {
	return &MockPlanner_Add_Call{Call: _e.mock.On("Add", p)}
}

func (_c *MockPlanner_Add_Call) Run(run func(p *Plan)) *MockPlanner_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*Plan))
	})
	return _c
}

func (_c *MockPlanner_Add_Call) Return(err error) *MockPlanner_Add_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlanner_Add_Call) RunAndReturn(run func(p *Plan) error) *MockPlanner_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockPlanner
func (_mock *MockPlanner) Delete(id int64) error {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int64) error); ok {
		r0 = returnFunc(id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlanner_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockPlanner_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - id
func (_e *MockPlanner_Expecter) Delete(id interface{}) *MockPlanner_Delete_Call {
	return &MockPlanner_Delete_Call{Call: _e.mock.On("Delete", id)}
}

func (_c *MockPlanner_Delete_Call) Run(run func(id int64)) *MockPlanner_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64))
	})
	return _c
}

func (_c *MockPlanner_Delete_Call) Return(err error) *MockPlanner_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlanner_Delete_Call) RunAndReturn(run func(id int64) error) *MockPlanner_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockPlanner
func (_mock *MockPlanner) GetByID(id int64, cfg *config.Config) (*Plan, error) {
	ret := _mock.Called(id, cfg)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *Plan
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, *config.Config) (*Plan, error)); ok {
		return returnFunc(id, cfg)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, *config.Config) *Plan); ok {
		r0 = returnFunc(id, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Plan)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, *config.Config) error); ok {
		r1 = returnFunc(id, cfg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlanner_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockPlanner_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id
//   - cfg
func (_e *MockPlanner_Expecter) GetByID(id interface{}, cfg interface{}) *MockPlanner_GetByID_Call {
	return &MockPlanner_GetByID_Call{Call: _e.mock.On("GetByID", id, cfg)}
}

func (_c *MockPlanner_GetByID_Call) Run(run func(id int64, cfg *config.Config)) *MockPlanner_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(*config.Config))
	})
	return _c
}

func (_c *MockPlanner_GetByID_Call) Return(plan *Plan, err error) *MockPlanner_GetByID_Call {
	_c.Call.Return(plan, err)
	return _c
}

func (_c *MockPlanner_GetByID_Call) RunAndReturn(run func(id int64, cfg *config.Config) (*Plan, error)) *MockPlanner_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetDueAndMark provides a mock function for the type MockPlanner
func (_mock *MockPlanner) GetDueAndMark(now time.Time) ([]Plan, error) {
	ret := _mock.Called(now)

	if len(ret) == 0 {
		panic("no return value specified for GetDueAndMark")
	}

	var r0 []Plan
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(time.Time) ([]Plan, error)); ok {
		return returnFunc(now)
	}
	if returnFunc, ok := ret.Get(0).(func(time.Time) []Plan); ok {
		r0 = returnFunc(now)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Plan)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(time.Time) error); ok {
		r1 = returnFunc(now)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPlanner_GetDueAndMark_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDueAndMark'
type MockPlanner_GetDueAndMark_Call struct {
	*mock.Call
}

// GetDueAndMark is a helper method to define mock.On call
//   - now
func (_e *MockPlanner_Expecter) GetDueAndMark(now interface{}) *MockPlanner_GetDueAndMark_Call {
	return &MockPlanner_GetDueAndMark_Call{Call: _e.mock.On("GetDueAndMark", now)}
}

func (_c *MockPlanner_GetDueAndMark_Call) Run(run func(now time.Time)) *MockPlanner_GetDueAndMark_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time))
	})
	return _c
}

func (_c *MockPlanner_GetDueAndMark_Call) Return(plans []Plan, err error) *MockPlanner_GetDueAndMark_Call {
	_c.Call.Return(plans, err)
	return _c
}

func (_c *MockPlanner_GetDueAndMark_Call) RunAndReturn(run func(now time.Time) ([]Plan, error)) *MockPlanner_GetDueAndMark_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockPlanner
func (_mock *MockPlanner) List(chatID int64, pageNumber int, cfg *config.Config) ([]Plan, bool, bool, error) {
	ret := _mock.Called(chatID, pageNumber, cfg)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []Plan
	var r1 bool
	var r2 bool
	var r3 error
	if returnFunc, ok := ret.Get(0).(func(int64, int, *config.Config) ([]Plan, bool, bool, error)); ok {
		return returnFunc(chatID, pageNumber, cfg)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int, *config.Config) []Plan); ok {
		r0 = returnFunc(chatID, pageNumber, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Plan)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int, *config.Config) bool); ok {
		r1 = returnFunc(chatID, pageNumber, cfg)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(int64, int, *config.Config) bool); ok {
		r2 = returnFunc(chatID, pageNumber, cfg)
	} else {
		r2 = ret.Get(2).(bool)
	}
	if returnFunc, ok := ret.Get(3).(func(int64, int, *config.Config) error); ok {
		r3 = returnFunc(chatID, pageNumber, cfg)
	} else {
		r3 = ret.Error(3)
	}
	return r0, r1, r2, r3
}

// MockPlanner_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockPlanner_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - chatID
//   - pageNumber
//   - cfg
func (_e *MockPlanner_Expecter) List(chatID interface{}, pageNumber interface{}, cfg interface{}) *MockPlanner_List_Call {
	return &MockPlanner_List_Call{Call: _e.mock.On("List", chatID, pageNumber, cfg)}
}

func (_c *MockPlanner_List_Call) Run(run func(chatID int64, pageNumber int, cfg *config.Config)) *MockPlanner_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int), args[2].(*config.Config))
	})
	return _c
}

func (_c *MockPlanner_List_Call) Return(plans []Plan, hasPrev bool, hasNext bool, err error) *MockPlanner_List_Call {
	_c.Call.Return(plans, hasPrev, hasNext, err)
	return _c
}

func (_c *MockPlanner_List_Call) RunAndReturn(run func(chatID int64, pageNumber int, cfg *config.Config) ([]Plan, bool, bool, error)) *MockPlanner_List_Call {
	_c.Call.Return(run)
	return _c
}

// PartnersChatIDs provides a mock function for the type MockPlanner
func (_mock *MockPlanner) PartnersChatIDs() []int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PartnersChatIDs")
	}

	var r0 []int64
	if returnFunc, ok := ret.Get(0).(func() []int64); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int64)
		}
	}
	return r0
}

// MockPlanner_PartnersChatIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PartnersChatIDs'
type MockPlanner_PartnersChatIDs_Call struct {
	*mock.Call
}

// PartnersChatIDs is a helper method to define mock.On call
func (_e *MockPlanner_Expecter) PartnersChatIDs() *MockPlanner_PartnersChatIDs_Call {
	return &MockPlanner_PartnersChatIDs_Call{Call: _e.mock.On("PartnersChatIDs")}
}

func (_c *MockPlanner_PartnersChatIDs_Call) Run(run func()) *MockPlanner_PartnersChatIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPlanner_PartnersChatIDs_Call) Return(int64s []int64) *MockPlanner_PartnersChatIDs_Call {
	_c.Call.Return(int64s)
	return _c
}

func (_c *MockPlanner_PartnersChatIDs_Call) RunAndReturn(run func() []int64) *MockPlanner_PartnersChatIDs_Call {
	_c.Call.Return(run)
	return _c
}

// Schedule provides a mock function for the type MockPlanner
func (_mock *MockPlanner) Schedule(id int64, t time.Time) error {
	ret := _mock.Called(id, t)

	if len(ret) == 0 {
		panic("no return value specified for Schedule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(int64, time.Time) error); ok {
		r0 = returnFunc(id, t)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPlanner_Schedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Schedule'
type MockPlanner_Schedule_Call struct {
	*mock.Call
}

// Schedule is a helper method to define mock.On call
//   - id
//   - t
func (_e *MockPlanner_Expecter) Schedule(id interface{}, t interface{}) *MockPlanner_Schedule_Call {
	return &MockPlanner_Schedule_Call{Call: _e.mock.On("Schedule", id, t)}
}

func (_c *MockPlanner_Schedule_Call) Run(run func(id int64, t time.Time)) *MockPlanner_Schedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(time.Time))
	})
	return _c
}

func (_c *MockPlanner_Schedule_Call) Return(err error) *MockPlanner_Schedule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPlanner_Schedule_Call) RunAndReturn(run func(id int64, t time.Time) error) *MockPlanner_Schedule_Call {
	_c.Call.Return(run)
	return _c
}
